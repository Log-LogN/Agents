from __future__ import annotations

from typing import Any

import httpx

from .common import success, failure


async def get_osv_vuln(vuln_id: str) -> dict[str, Any]:
    """
    Fetch vulnerability/advisory details from OSV by ID.

    Supports IDs like GHSA-xxxx-xxxx-xxxx and CVE-YYYY-NNNN.
    """
    vid = (vuln_id or "").strip()
    if not vid:
        return failure("vuln_id is required.")

    url = f"https://api.osv.dev/v1/vulns/{vid}"

    try:
        async with httpx.AsyncClient(timeout=httpx.Timeout(20.0)) as client:
            r = await client.get(url, headers={"User-Agent": "cybersecurity-agent/vuln"})
            if r.status_code == 404:
                return failure(f"OSV has no entry for {vid}.")
            r.raise_for_status()
            payload = r.json()

        # Normalize key fields for SOC usefulness.
        aliases = payload.get("aliases") or []
        related = payload.get("related") or []
        summary = payload.get("summary") or ""
        details = payload.get("details") or ""

        affected = payload.get("affected") or []
        affected_slim: list[dict[str, Any]] = []
        for a in affected:
            pkg = a.get("package") or {}
            ecosystem = pkg.get("ecosystem")
            name = pkg.get("name")
            ranges = a.get("ranges") or []
            versions = a.get("versions") or []
            affected_slim.append(
                {
                    "package": {"ecosystem": ecosystem, "name": name},
                    "ranges": ranges,
                    "versions": versions,
                }
            )

        references = payload.get("references") or []
        refs = [{"type": r.get("type"), "url": r.get("url")} for r in references if isinstance(r, dict)]

        severity = payload.get("severity") or []
        sev = [{"type": s.get("type"), "score": s.get("score")} for s in severity if isinstance(s, dict)]

        return success(
            {
                "id": payload.get("id") or vid,
                "modified": payload.get("modified"),
                "published": payload.get("published"),
                "summary": summary,
                "details": details,
                "aliases": aliases,
                "related": related,
                "severity": sev,
                "affected": affected_slim,
                "references": refs,
            }
        )
    except Exception as e:
        return failure(str(e))

